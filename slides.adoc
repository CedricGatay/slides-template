= Développer sur Android : quelques librairies à connaître
:author: Joris Potier
:keywords: @Joris_Potier
:email: j.potier@code-troopers.com
:backend: deckjs
:customcss: ct/ct.css
:customjs: ct/ct.js
:deckjs_transition: horizontal-slide
:goto:
:menu:
:status:
:imagesdir: ./images
:source-highlighter: pygments

== Joris POTIER
[cols="3a,1a"]
|===
|
* \http://code-troopers.com
* \j.potier@code-troopers.com
* @Joris_Potier
* \https://github.com/JorisPotier 
* \https://github.com/code-troopers
|image::profile.jpeg[]

|
[width="75%", cols="3*"]
!===
!image:navigtours-logo.png[] 
!image:aucard.png[] 
!image:terresduson-logo.png[] 

!image:nowly-logo.png[] 
!image:srmvision-logo.png[]
a!//
!===
|image::logo_text.png[]
|===



== Disclaimer
* Librairies adaptées au développement sur Android, mais pas que
* Sélection complètement subjective
* Simple retour d'expérience
* Quelques exemples d'implémentation : https://github.com/code-troopers/material-android-bootstrap


== Sommaire
* Timber
* Dagger 2
* Butterknife
* Otto
* Retrofit
* Picasso
* OkHttp

== Timber

== Timber
* https://github.com/JakeWharton/timber
* API de logging
* Permet de s'abstraire de la classe Log du SDK Android
* Pouvoir injecter ses propres loggers facilement

== Timber
Permet de s'abstraire de la classe Log du SDK Android :
[source, java]
----
Log.i(getClass().getName(), 
	"Hello Tours JUG!");
----
[source, java]
----
Log.i(getClass().getName(),
 	String.format("Hello %s!", userName));
----
[source, java]
----
Log.e(getClass().getName(), 
	"Oups", 
	exception);
----


== Timber
Permet de s'abstraire de la classe Log du SDK Android :
[source, java]
----
Log.i(getClass().getName(), 
	"Hello Tours JUG!");
----

[source]
----
04-19 18:48:07.500 2409-2409/com.ct.materialAndroidBootstrap 
I/com.ct.materialAndroidBootstrap.ui.activity.HomeActivity﹕ Hello Tours JUG!
----

== Timber
.Principe :
* configurer ses loggers auprès de Timber
* demander à Timber de tracer les informations en renseignant le minimum


== Timber
Configuration des loggers :
[source, java]
----
public class AndroidBootstrapApplication extends android.app.Application {
    @Override
    public void onCreate() {
        super.onCreate();
        if (BuildConfig.DEBUG) {
            Timber.plant(
            	new Timber.DebugTree());
        } else {
         // custom implementations 
         // can be made by 
         // extending Timber.HollowTree
         Timber.plant(
         	new CustomCrashReporter());
        }
    }
}
----
Possibilité de "planter" plusieurs loggers

== Timber
Tracer des informations : 
[source, java]
----
Timber.i("Hello Tours JUG!");
----
[source, java]
----
Timber.i("Hello %s!", userName);
----
[source, java]
----
Timber.e(exception, "Oups");
----

== Timber
Résultat du Timber.DebugTree : 
[source, java]
----
Timber.i("Hello Tours JUG!");
----

[source]
----
04-19 19:11:09.972 2514-2514/com.codetroopers.materialAndroidBootstrap 
I/HomeActivity﹕ Hello Tours JUG!
----

== Timber
.Conclusion :
* Simple et efficace
* Évite la recopie de code polluant
* Évite la réimplémentation d'une surcouche à la classe Log pour chaque projet

== Dagger 2

== Dagger 2
* https://github.com/google/dagger
* Framework d'injection de dépendances (DI)
* S'appuie sur des annotations standards (JSR300)
* Meilleure structuration du code
* Permet de se concentrer sur l'implémentation plutôt que sur configuration des modules
* Plus facile à tester, modules intercheangeables facilement

== Dagger 2
* De nombreux frameworks de DI 
** Spring
** Guice
** Dagger 1
** CDI
** etc...

* Mais contraintes de ressources sur Android
* Obfuscation du code difficile

== Dagger 2
* Guice (RoboGuice) : performances limitées car analyse des dépendances au Runtime
* Dagger 1
** génération de code à la compilation
** permet d'éviter au maximum la réflection au Runtime... mais quand même
** le code généré reste difficile à obfusquer
** le code généré est difficile à lire/débugger

== Dagger 2
* Fork de Dagger 1
* Release disponible depuis peu
* *Tout* le code est généré à la compilation
* Plus aucune analyse au Runtime
* Performances++
* Code généré très lisible/débuggable
* Plus aucun problème d'obfuscation
