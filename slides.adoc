= Android : Librairies utiles
:author: Joris Potier
:keywords: @Joris_Potier #Tours_Jug
:email: j.potier@code-troopers.com
:backend: deckjs
:customcss: ct/ct.css
:customjs: ct/ct.js
// :deckjs_transition: horizontal-slide
:goto:
:menu:
:status:
:imagesdir: ./images
:source-highlighter: pygments

== Joris Potier
[cols="3a,1a"]
|===
|
* \http://code-troopers.com
* \j.potier@code-troopers.com
* @Joris_Potier
* \https://github.com/JorisPotier 
* \https://github.com/code-troopers
|image::profile.jpeg[]

|
[width="75%", cols="3*"]
!===
!image:navigtours-logo.png[] 
!image:aucard.png[] 
!image:terresduson-logo.png[] 

!image:nowly-logo.png[] 
!image:srmvision-logo.png[]
a!//
!===
|image::logo_text.png[]
|===



== Disclaimer
* Librairies adaptées au développement sur Android, mais pas que
* Sélection complètement subjective
* Simple retour d'expérience
* Quelques exemples d'implémentation : https://github.com/code-troopers/material-android-bootstrap


== Sommaire
* Timber
* Dagger 2
* Butterknife
* Retrofit
* (Bonus ...)
////
* Otto
* Picasso
* OkHttp
////

== Timber

== Timber
* https://github.com/JakeWharton/timber
* API de logging
* Permet de s'abstraire de la classe Log du SDK Android
* Pouvoir injecter ses propres loggers facilement

== Timber
Permet de s'abstraire de la classe Log du SDK Android :
[source, java]
----
Log.i(getClass().getName(), 
	"Hello Tours JUG!");
----
[source, java]
----
Log.i(getClass().getName(),
 	String.format("Hello %s!", userName));
----
[source, java]
----
Log.e(getClass().getName(), 
	"Oups", 
	exception);
----
[source]
----
04-19 18:48:07.500 2409-2409/com.codetroopers.jug 
I/com.codetroopers.jug.ui.activity.HomeActivity﹕ Hello Tours JUG!
----

== Timber
Configuration des loggers :
[source, java]
----
public class MyApplication extends Application {
 @Override
 public void onCreate() {
  super.onCreate();

  if (BuildConfig.DEBUG) {
   Timber.plant(new Timber.DebugTree());
  } else {
   // custom implementations can be made by 
   // extending Timber.HollowTree
   Timber.plant(new CustomCrashReporter());
  }
 }
}
----
Possibilité de "planter" plusieurs loggers

== Timber
Tracer des informations : 
[source, java]
----
Timber.i("Hello Tours JUG!");
----
[source, java]
----
Timber.i("Hello %s!", userName);
----
[source, java]
----
Timber.e(exception, "Oups");
----
[source]
----
04-19 19:11:09.972 2514-2514/com.codetroopers.jug 
I/HomeActivity﹕ Hello Tours JUG!
----

////
== Timber
.Conclusion :
* Simple et efficace
* Évite la recopie de code polluant
* Évite la réimplémentation d'une surcouche à la classe Log pour chaque projet
////

== Dagger 2

== Dagger 2
* http://google.github.io/dagger
* Framework d'injection de dépendances (DI)
* Pour Android et Java
* S'appuie sur des annotations standards (JSR300)
* Meilleure structuration du code : DAOs, service d'authentification, Factories, ...
* Permet de se concentrer sur l'implémentation plutôt que sur la configuration des modules
* Plus facile à tester, modules interchangeables facilement

== Dagger 2
* De nombreux frameworks de DI 
** Spring
** Guice (RoboGuice)
** Dagger 1
** CDI
** etc...

* Mais contraintes de ressources sur Android donc performances limitées car traitements au Runtime
* Obfuscation du code difficile

== Dagger 2
* Fork de Dagger 1
* Release disponible depuis peu
* *Tout* le code est généré à la compilation (contrairement à Dagger 1)
** Plus aucune analyse au Runtime => Performances++
** Plus aucun problème d'obfuscation
* Code généré facilement lisible/débuggable

== Dagger 2
.Utilisation : étape 1, écriture des modules
* on indique à Dagger comment fournir une dépendance => Instanciation + Configuration
* on indique à Dagger le "scope" des dépendances
[source, java]
@Module
public class MyModule {
 @Singleton
 @Provides
 DataSource provideDataSource() {
  return new DataSource();
 }
 @Provides
 ContactDao provideContactDao(DataSource ds) {
  ContactDao dao = new ContactDao();
  dao.setDataSource(ds);
  return dao;
 }
}
* Dagger se chargera à la compilation de l'analyse du graphe de dépendances (qui dépend de qui) via les annotations, les valeurs de retour et les paramètres

== Dagger 2
* Possibilité de faire de la composition de modules pour construire le graphe final
[source, java]
@Module
public class AndroidModule {
 @Provides
 @Singleton
 Context provideApplicationContext() {
  return MyApplication.getInstance();
 }
 @Provides
 @Singleton
 LocationManager provideLocMngr(Context ctx) {
  return (LocationManager) 
      ctx.getSystemService(LOCATION_SERVICE);
 }
 @Provides
 SharedPreferences providePreferences(Context ctx) {
  return PreferenceManager
      .getDefaultSharedPreferences(ctx);
 }
}

////
== Dagger 2
.Utilisation : étape 2, demander une dépendance
* @Inject sur un constructeur 
** un paramètre = une dépendance
** permet donc d'éliminer des @Provides

[source, java]
----
public class ContactDao {
 private final DataSource dataSource;
 @Inject
 public ContactDao(DataSource dataSource) {
  this.dataSource = dataSource;
 }
}
----
[source, java]
@Module
public class MyModule {
 @Singleton
 @Provides
 DataSource provideDataSource() {
  return new DataSource();
 }
 /* 
 @Provides
 ContactDao provideContactDao(DataSource ds) {
  ContactDao dao = new ContactDao();
  dao.setDataSource(ds);
  return dao;
 }
 */
}
////

////
== Dagger 2

[source, java]
----
@Singleton
public class DataSource {
	@Inject
	public DataSource() {
		// ...
	}
}
----
[source, java]
@Module
public class MyModule {
	/* @Singleton
	@Provides
	DataSource provideDataSource() {
		return new DataSource();
	}
	@Provides
	ContactDao provideContactDao(DataSource ds) {
		ContactDao dao = new ContactDao();
		dao.setDataSource(ds);
		return dao;
	} */
}
////

== Dagger 2
.Utilisation : étape 2, demander une dépendance
* @Inject sur une méthode
** un paramètre = une dépendance
** seul cas d'utilisation : on veut passer "this" à la dépendance (ex : bus.register(this);)
* @Inject sur un champ
** cas d'utilisation : l'instance n'est pas créée par l'utilisateur
** particulièrement utile sur Android pour les instances créées par le système (ex: Activity, Fragment, ...)

== Dagger 2
[source, java]
----
public class MyActivity extends Activity {
 @Inject
 ContactDao contactDao;

 @Override
 protected void onCreate(Bundle b) {
  /* ... */
  /* Déclenchement des injections... à suivre ! */
  TextView textView = /* ... */
  textView.setText(contactDao.getRandomContact());
 }
}
----

== Dagger 2
.Utilisation : étape 3, faire le lien entre les @Module et les @Inject => l'"Injecteur"
* on indique à Dagger les modules concernés par notre injecteur
* on indique à Dagger qui va demander des injections par une interface
* l'implémentation de l'interface est fournie directement par Dagger
[source, java]
@Singleton
@Component(
 modules = {
  AndroidModule.class,
  MyModule.class
 }
)
public interface Injector {
 void inject(MyActivity activity);
}

== Dagger 2
[source, java]
----
public class MyApplication extends Application {
 public static Injector injector;

 @Override
 public void onCreate() {
  super.onCreate();
  injector = DaggerInjector.create();
 }
}
----

== Dagger 2
[source, java]
----
public class MyActivity extends Activity {
 @Inject
 ContactDao contactDao;

 @Override
 protected void onCreate(Bundle b) {
  /* ... */
  MyApplication.injector.inject(this);
  TextView textView = /* ... */
  textView.setText(contactDao.getRandomContact());
 }
}
----

== Dagger 2
.En résumé :
* Fournir une dépendance : implémentation des modules
** @Provides : pour les méthodes qui fournissent les instances, avec éventuellement des dépendances à satisfaire => Configuration
** @Module : pour définir les classes qui fournissent un ensemble de dépendances
* Demander une dépendance : 
** @Inject : lorsqu'on désire injecter un service donné, sans se soucier de son implémentation (et donc ses propres dépendances...)
* Mécanisme pour relier les 2 :
** @Component : "l'injecteur", permet de déléguer au compilateur l'écriture du code sans valeur ajoutée qui fera la glue

== Dagger 2
.Bonus :
* Mocks injectables dans les tests par simple extension des modules, mais pas encore de pattern standardisé
* De nombreuses options, se référer à la documentation :
** Custom Scopes possible
** Lazy injections
** Provider injections
** Qualifier

== Butter Knife

== Butter Knife
* http://jakewharton.github.io/butterknife
* Framework d'injection de view Android
// * Permet de mapper simplement les composants d'une vue à partir de son ID
// * Typage des vues injectées

== Butter Knife
[source, xml]
.my_activity.xml
----
<!-- ... -->
<TextView
 android:id="@+id/contact"
 android:layout_width="wrap_content"
 android:layout_height="wrap_content"
 android:text="" />
<!-- ... -->
----
[source, java]
----
public class MyActivity extends Activity {
 @Inject
 ContactDao contactDao;

 @InjectView(R.id.contact)
 TextView textView;

 @Override
 protected void onCreate(Bundle b) {
  super.onCreate(b);
  setContentView(R.layout.my_activity);
  MyApplication.injector.inject(this);

  /*
  TextView textView = 
    (TextView) findViewById(R.id.contact);
  */
  ButterKnife.inject(this);
  textView.setText(contactDao.getRandomContact());
 }
}
----

////
== Butter Knife
Possibilité d'injecter une liste de Views pour faire des traitements par lots
[source, java]
----
@InjectViews(
 { 
  R.id.first_name, 
  R.id.middle_name, 
  R.id.last_name 
 }
)
List<EditText> nameViews;

// ...

ButterKnife.apply(nameViews, DISABLE);
ButterKnife.apply(nameViews, ENABLED, false);
ButterKnife.apply(nameViews, View.ALPHA, 0);
----
////

== Butter Knife
Possibilité d'injecter des listeners : 
[source, java]
----
@OnClick(R.id.contact)
public void onClickContact(TextView textView) {
  textView.setText("Hello!");
}
----

== Butter Knife
* D'autres options sont disponibles, se référer à la documentation : 
** @OnItemSelected
** @OnLongClick, 
** @OnTouch, 
** @OnCheckedChanged, 
** @OnPageChange, 
** ...
* Simple et efficace
* Toute la "glue" est gérée par Butter Knife => gain en lisibilité, donc en maintenabilité
* Aucune réflexion, tout le code est généré à la compilation => n'affecte pas les performances

== Retrofit

== Retrofit
* http://square.github.io/retrofit
* Client REST pour Android et Java
* Permet de mapper facilement une interface java à une API REST

== Retrofit
Gestion des appels synchrones
[source, java]
----
public interface ContactService {
 
 @GET("/contacts/{contactId}")
 Contact getContact(
    @Path("contactId") Long contactId);

 @DELETE("/contacts")
 Response deleteContact(
    @Query("firstName") String firstName, 
    @Query("lastName") String lastName);

  // ...
}
----

== Retrofit
Gestion des appels asynchrones
[source, java]
----
public interface ContactService {

 @GET("/contacts")
 void listContacts(
    Callback<List<Contact>> callback);

 @POST("/contacts/create")
 void createContact(
    @Body Contact contact, 
    Callback<Contact> callback);

  // ...
}
----

== Retrofit
L'implémentation est alors fournie par la classe RestAdapter de l'API :
[source, java]
----
@Module
public class RestModule {
 @Singleton
 @Provides
 ContactService provideContactService() {
  RestAdapter restAdapter = 
     new RestAdapter
       .Builder()
       .setEndpoint("http://code-troopers.com")
       .build();

  return restAdapter.create(ContactService.class);
 }
}
----

== Retrofit
Chaque appel sur le service généré effectue une requête HTTP au web service
[source, java]
----
@Inject
ContactService service;
// ...
Contact c = service.getContact(10L);
----

[source, java]
----
service.listContacts(new Callback<List<Contact>>() {
 @Override
 public void success(List<Contact> contacts, 
                     Response response) {
  Timber.i("Nombre de contacts reçus = %d", 
           contacts.size());
 }

 @Override
 public void failure(RetrofitError error) {
  Timber.e("Unable to get contacts : %s", error);
 }
});
----

== Retrofit
* De nombreuses options possibles, se référer à la documentation : 
** Converters personnalisés (sérialisation JSON par défaut)
** Form-encoded, Multipart
** manipulation du header
** Utilisation de RxJava pour remplacer les Callbacks
** ...

== Bonus
* Otto 
** http://square.github.io/otto
** Gestion d'évènements synchrones sur un Bus
** Forte valeur ajoutée en combinaison avec Retrofit en mode asynchrone
* Picasso
** http://square.github.io/picasso/
** Gestion améliorée des images sur Android
** Téléchargement simplifié
** Gestion de cache
* OkHttp
** http://square.github.io/okhttp/
** un client HTTP simple et performant
* Et bien d'autres!

== Questions ?
* https://github.com/code-troopers/material-android-bootstrap
* https://github.com/JakeWharton/timber
* http://google.github.io/dagger
** https://www.parleys.com/tutorial/the-future-dependency-injection-dagger-2
** https://www.youtube.com/watch?v=oK_XtfXPkqw
* http://jakewharton.github.io/butterknife
* http://square.github.io/retrofit

== Merci